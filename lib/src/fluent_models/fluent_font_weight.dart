class FluentFontWeight {
  const FluentFontWeight._(this.index, this.value);

  /// The encoded integer value of this font weight.
  final int index;

  /// The thickness value of this font weight.
  final int value;

  ///  regular
  static const FluentFontWeight regular = FluentFontWeight._(0, 400);

  /// Semi-bold
  static const FluentFontWeight semibold = FluentFontWeight._(1, 600);

  /// Bold
  static const FluentFontWeight bold = FluentFontWeight._(2, 700);

  /// A list of all the font weights.
  static const List<FluentFontWeight> values = <FluentFontWeight>[
    regular,
    semibold,
    bold,
  ];

  /// Linearly interpolates between two font weights.
  ///
  /// Rather than using fractional weights, the interpolation rounds to the
  /// nearest weight.
  ///
  /// If both `a` and `b` are null, then this method will return null. Otherwise,
  /// any null values for `a` or `b` are interpreted as equivalent to [regular]
  /// (also known as [w400]).
  ///
  /// The `t` argument represents position on the timeline, with 0.0 meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  /// 1.0, so negative values and values greater than 1.0 are valid (and can
  /// easily be generated by curves such as [Curves.elasticInOut]). The result
  /// is clamped to the range [w100]â€“[w900].
  ///
  /// Values for `t` are usually obtained from an [Animation<double>], such as
  /// an [AnimationController].
  static FluentFontWeight? lerp(
      FluentFontWeight? a, FluentFontWeight? b, double t) {
    if (a == null && b == null) {
      return null;
    }
    return values[_lerpInt((a ?? regular).index, (b ?? regular).index, t)
        .round()
        .clamp(0, 8)];
  }

  @override
  String toString() {
    return const <int, String>{
      0: 'FluentFontWeight.regular',
      1: 'FluentFontWeight.semibold',
      2: 'FluentFontWeight.bold',
    }[index]!;
  }
}

/// Linearly interpolate between two integers.
///
/// Same as [lerpDouble] but specialized for non-null `int` type.
double _lerpInt(int a, int b, double t) {
  return a + (b - a) * t;
}
